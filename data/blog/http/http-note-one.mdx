---
title: Http笔记(一)
date: 2023-03-01T23:39:14Z
tags: ['Http']
draft: false
summary: '记录下http的笔记'
authors: ['default']
---

import TOCInline from 'pliny/ui/TOCInline'

<TOCInline toc={props.toc} exclude="Overview" toHeading={2} />

# HTTP(HyperText Transfer Protocol)

<div className="text-3xl font-bold text-white">http整体思维导图入下图⬇️</div>

![](/blog/http思维导图.png)

拿个图来帮助理解下`超文本传输协议`这几个字

![](/blog/http解释.png)

## HTTP/0.9

- 特点:
  - 只允许用`GET`从服务器获取 HTML 文档,并在响应请求后立即关闭连接,功能有限
  - 同时传输的数据只为纯文本

## HTTP/1.0

- 特点:
  1. 增加了 `HEAD`、`POST` 等方法
  2. 增加了响应状态码,标记可能的错误原因
  3. 引入了协议版本号概念
  4. 引入了 HTTP Header(头部)的概念,让 HTTP 处理请求和响应更加灵活
  5. 传输的数据不再仅限于文本

## HTTP/1.1

- 特点:
  1. 增加了 `PUT`、`DELETE` 等方法
  2. 增加了缓存管理和控制
  3. 明确了连接管理,允许`持久链接`
  4. 强制要求 Host 头,让互联网主机托管成为可能

## HTTP/2

- 位于应用层
- 默认无加密
- HTTP/2 基于 Google 的 `SPDY` 协议
- HTTP/2 考虑了现今互联网的现状:宽带、移动、不安全,在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力,特点如下:
  1. 二进制协议,不再是纯文本
  2. 可发起多个请求,发起了 1.1 里的管道
  3. 使用专用算法压缩头部,减少数据传输量
  4. 允许服务器主动向客户端推送数据
  5. 增强了安全性,主要是要求了`加密通信`

## HTTP/3

- 位于传输层
- 默认有加密
- 基于 Google 发明的基于 `UDP` 的 `QUIC` 协议
- 选择 http3 就意味着传输层协议从原来的`TCP`转而选择了`UDP`,也就选择了`UDP`的特性:
  - 不需要再使用三次握手建立连接,

## HTTP 是什么

- HTTP 是一个用在计算机世界里的协议,它确立了一种计算机之间交流通信的规范,以及相关的各种控制和错误处理方式
- HTTP 专门用来在两点之间传输数据,不能用于广播、寻址或路由
- HTTP 传输的是文字、图片、音频、视频等超文本数据
- HTTP 是构建互联网的重要基础技术,它没有实体,依赖许多其他的技术来实现,但同时许多技术也都依赖于它

## 请求方与响应方

- 互联网上绝大部分资源都使用 HTTP 协议传输
- 浏览器是 HTTP 协议里的请求方,即 User Agent
- 服务器是 HTTP 协议里的应答方,常用的有 Apache 和 Nginx
- CDN 位于浏览器和服务器之间,主要起到缓存加速的作用
  - CDN 实质上就是一种代理,代替服务器响应客户端的请求,通常扮演透明代理和反向代理的角色
- 爬虫是另一类 User Agent,是自动访问网络资源的程序

## TCP/IP

`TCP/IP` 协议实际上是一系列网络通信协议的统称,其中最核心的两个协议是 TCP 和 IP,其他的还有 UDP、ICMP、ARP 等等,共同构成了一个复杂但有层次的协议栈.这个协议栈有四层,最上层是`应用层`,最下层是`链接层`,TCP 和 IP 则在中间:TCP 属于`传输层`,IP 属于`网际层`

- `IP` 协议:IP 协议是“Internet Protocol”的缩写,主要目的是解决寻址和路由问题,以及如何在两点间传送数据包.IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机
- `TCP` 协议:TCP 协议是“Transmission Control Protocol”的缩写,意思是“传输控制协议”,它位于 IP 协议之上,基于 IP 协议提供可靠的、字节流形式的通信,是 HTTP 协议得以实现的基础

HTTP 是一个"传输协议",但它不关心寻址、路由、数据完整性等传输细节,而要求这些工作都由下层来处理.因为互联网上最流行的是 TCP/IP 协议,而它刚好满足 HTTP 的要求,所以互联网上的 HTTP 协议就运行在了 TCP/IP 上,HTTP 也就可以更准确地称为“HTTP over TCP/IP”

## DNS(Domain Name System)

DNS 域名是 IP 地址的等价替代,需要用域名解析实现到 IP 地址的映射

## URI(Uniform Resource Identifier)/URL(Uniform Resource Locator)

URL 实际是 URI 的一个子集(但差异不大),都是标记互联网资源

`http://nginx.org/en/download.html`

- URI 的三个基本的部分构成:

  1. 协议名:即访问该资源应当使用的协议,在这里是`http`
  2. 主机名:即互联网上主机的标记,可以是域名或 IP 地址,在这里是`nginx.org`
  3. 路径:即资源在主机上的位置,使用“/”分隔多级目录,在这里是`/en/download.html`

## HTTPS(HTTP over SSL/TLS)

HTTPS 中 HTTP 运行在 SSL/TLS 上,而 SSL/TLS 又是运行在 TCP/IP 之上的协议,所以三者由 HTTP、SSL/TLS、TCP/IP 层层往下,TCP/IP 为最底层基础

## Proxy

代理(Proxy)是 HTTP 协议中请求方和应答方中间的一个环节,作为“中转站”,既可以转发客户端的请求,也可以转发服务器的应答

- 常见的代理种类有:

  1. 匿名代理:完全“隐匿”了被代理的机器,外界看到的只是代理服务器
  2. 透明代理:顾名思义,它在传输过程中是“透明开放”的,外界既知道代理,也知道客户端
  3. 正向代理:靠近客户端,代表客户端向服务器发送请求
  4. 反向代理:靠近服务器端,代表服务器响应客户端的请求

- 由于代理在传输过程中插入了一个“中间层”,所以可以在这个环节做很多有意思的事情,比如:
  1. 负载均衡:把访问请求均匀分散到多台机器,实现访问集群化
  2. 内容缓存:暂存上下行的数据,减轻后端的压力
  3. 安全防护:隐匿 IP, 使用 WAF 等工具抵御网络攻击,保护被代理的机器
  4. 数据处理:提供压缩、加密等额外的功能

## TCP/IP 网络分层模型

![](/blog/TCP:IP四层模型.png)

该模型是从下往上数,所以第一层为 `link layer`

- 然后第三层除了 TCP 还有 UDP,对比一下两个协议:

  - 从状态来看
    - `TCP` 是一个有状态的协议,需要先与对方建立连接然后才能发送数据,而且保证数据不丢失不重复
    - `UDP` 则比较简单,它无状态,不用事先建立连接就可以任意发送数据,但不保证数据一定会发到对方.
  - 从数据形式来看:
    - `TCP` 的数据是连续的“字节流”,有先后顺序
    - `UDP` 则是分散的小数据包,是顺序发,乱序收

## OSI 网络分层模型(Open System Interconnection Reference Model)

![](/blog/OSI模型.png)

1. 第一层:物理层,网络的物理形式,例如电缆、光纤、网卡、集线器等等；
2. 第二层:数据链路层,它基本相当于 TCP/IP 的链接层；
3. 第三层:网络层,相当于 TCP/IP 里的网际层；
4. 第四层:传输层,相当于 TCP/IP 里的传输层；
5. 第五层:会话层,维护网络中的连接状态,即保持会话和同步；
6. 第六层:表示层,把数据转换为合适、可理解的语法和语义；
7. 第七层:应用层,面向具体的应用传输数据

## 两个模型的映射关系

![](/blog/映射关系.png)

因为 TCP/IP 是一个纯软件的栈,没有网络应有的最根基的电缆、网卡等物理设备的位置

## 域名的解析

- DNS 的核心系统是一个三层的树状、分布式服务,基本对应域名的结构:

  1. `根域名服务器(Root DNS Server)`:管理顶级域名服务器,返回`com` `net` `cn`等顶级域名服务器的 IP 地址
  2. `顶级域名服务器(Top-level DNS Server)`:管理各自域名下的权威域名服务器,比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址
  3. `权威域名服务器(Authoritative DNS Server)`:管理自己域名下主机的 IP 地址,比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址

- 如果你要访问`www.apple.com`,就要进行下面的三次查询:

  1. 访问根域名服务器,它会告诉你`com`顶级域名服务器的地址
  2. 访问`com`顶级域名服务器,它再告诉你`apple.com`域名服务器的地
  3. 最后访问`apple.com`域名服务器,就得到了`www.apple.com`的地址

- 域名解析核心是通过`DNS系统`,但即便性能很高,在全球的负载下难免会有压力,而常用有两种手段减轻域名解析的压力,基本思路都是`缓存`:

  1. 许多大公司、网络运行商都会建立自己的 DNS 服务器,作为用户 DNS 查询的代理,代替用户访问核心 DNS 系统。这些`野生`服务器被称为`非权威域名服务器`,可以缓存之前的查询结果,如果已经有了记录,就无需再向根服务器发起查询,直接返回对应的 IP 地址
  2. 操作系统里也会对 DNS 解析结果做缓存,如果你之前访问过`www.apple.com`,那么下一次在浏览器里再输入这个网址的时候就不会再跑到 DNS 那里去问了,直接在操作系统里就可以拿到 IP 地址

- 在 Nginx 里有这么一条配置指令`resolver`,它就是用来配置 DNS 服务器的,如果没有它,那么 Nginx 就无法查询域名对应的 IP,也就无法反向代理到外部的网站

  ```nginx
  resolver 8.8.8.8 valid=30s;  # 指定 Google 的 DNS,缓存 30 秒
  ```

- 域名的玩法:

  - 重定向:原主机 IP 地址变动需要下线、迁移时,可以更改 DNS 记录,让域名指向其它的机器
  - 因为域名是一个名字空间,所以可以使用 bind9 等开源软件搭建一个在内部使用的 DNS,作为名字服务器。这样我们开发的各种内部服务就都用域名来标记,比如数据库服务都用域名“mysql.inner.app”,商品服务都用“goods.inner.app”,发起网络通信时也就不必再使用写死的 IP 地址了,可以直接用域名
  - 基于域名实现的负载均衡:
    - 因为域名解析可以返回多个 IP 地址,所以一个域名可以对应多台主机,客户端收到多个 IP 地址后,就可以自己使用轮询算法依次向服务器发起请求,实现负载均衡
    - 域名解析可以配置内部的策略,返回离客户端最近的主机,或者返回当前服务质量最好的主机,这样在 DNS 端把请求分发到不同的服务器,实现负载均衡
