---
title: Rustå…¥é—¨ç¬”è®°(å…­)
date: '2023-6-20'
tags: ['Rust', 'Rustå…¥å‘ç³»åˆ—']
draft: false
summary: 'Rust å®ç°å‘é‡æœç´¢(Vector search)'
authors: ['default']
---

import TOCInline from 'pliny/ui/TOCInline'

<TOCInline toc={props.toc} exclude="Overview" toHeading={3} />

# Vectors(Embeddings) ç®€ä»‹

å‘é‡ç”¨äºåœ¨æ•°æ®åº“ä¸­å­˜å‚¨æ–‡æ¡£ã€å›¾åƒã€è§†é¢‘ç­‰å¤æ‚çš„éç»“æ„åŒ–æ•°æ®,å¹¶æŸ¥æ‰¾åŸºäºè¯¥ç±»å‹ä¸‹çš„ç›¸ä¼¼å•ä½ç­‰æƒ…å†µ

å‘é‡ä¸ä¸€å®šæ˜¯ä¸‰ç»´çš„(å¯èƒ½æ˜¯æ›´å¤šçº¬åº¦),ä¹‹é—´çš„è·ç¦»ä¹Ÿä¸ä¸€å®šå¿…é¡»æ˜¯ `euclidean distance`(æ¬§å¼è·ç¦»),é‡è¦çš„æ˜¯å®ƒä»¬ä¹‹é—´çš„è·ç¦»å¯¹åº”äºå®ƒä»¬çš„ç›¸ä¼¼æ€§

æˆ‘ä»¬å¦‚ä½•æ‰¾åˆ°ä¸ç»™å®šèµ·å§‹è§†é¢‘æœ€ç›¸ä¼¼çš„è§†é¢‘? ç®€å•æ¥è¯´,å…ˆéå†æ‰€æœ‰è§†é¢‘,è®¡ç®—å®ƒä»¬ä¹‹é—´çš„è·ç¦»å¹¶é€‰æ‹©è·ç¦»æœ€å°çš„è§†é¢‘ - ä¹Ÿç§°ä¸ºæŸ¥æ‰¾æŸ¥è¯¢è§†é¢‘çš„ `æœ€è¿‘é‚»å±…`;ä½†æ˜¯è¿™æ · O(N)çš„çº¿æ€§æŸ¥æ‰¾æˆæœ¬ ğŸ’° å¤ªè¿‡æ˜‚è´µ

åœ¨å®é™…æƒ…å†µä¸‹,æˆ‘ä»¬ä¸éœ€è¦æ‰¾åˆ°æœ€è¿‘çš„è§†é¢‘â€”â€”æ‰¾åˆ°è¶³å¤Ÿæ¥è¿‘çš„è§†é¢‘ä¹Ÿå¯ä»¥.è¿™å°±æ˜¯`è¿‘ä¼¼æœ€è¿‘é‚»æœç´¢ç®—æ³•(çŸ¢é‡æœç´¢)`çš„ç”¨æ­¦ä¹‹åœ°; ç›®æ ‡æ˜¯`æ¬¡çº¿æ€§åœ°(ç†æƒ³æƒ…å†µä¸‹åœ¨å¯¹æ•°æ—¶é—´å†…)`æ‰¾åˆ°ç©ºé—´ä¸­ä»»ä½•ç‚¹çš„è¶³å¤Ÿè¿‘çš„æœ€è¿‘é‚»

# å¦‚ä½•å®ç°æŸ¥æ‰¾æœ€è¿‘é‚»å±…

`æ‰€æœ‰çŸ¢é‡æœç´¢ç®—æ³•`èƒŒåçš„åŸºæœ¬æ€æƒ³éƒ½æ˜¯ç›¸åŒçš„ â€”â€” è¿›è¡Œä¸€äº›é¢„å¤„ç†ä»¥è¯†åˆ«å½¼æ­¤è¶³å¤Ÿæ¥è¿‘çš„ç‚¹(æœ‰ç‚¹ç±»ä¼¼äºå»ºç«‹ç´¢å¼•);åœ¨æŸ¥è¯¢æ—¶,ä½¿ç”¨è¿™ä¸ª`ç´¢å¼•`æ¥æ’é™¤å¤§èŒƒå›´çš„ç‚¹.å¹¶åœ¨ä¸æ’é™¤çš„å°‘é‡ç‚¹å†…è¿›è¡Œçº¿æ€§æ‰«æ

å‡ ç§æœ€å…ˆè¿›çš„çŸ¢é‡æœç´¢ç®—æ³•,ä¾‹å¦‚ `HNSW(ä¸€ç§è¿æ¥è¿‘è·ç¦»é¡¶ç‚¹å¹¶é€šè¿‡å›ºå®šå…¥å£ç‚¹ä¿æŒé•¿è·ç¦»è¾¹çš„å›¾)`.å­˜åœ¨å¼€æºé¡¹ç›®,ä¾‹å¦‚ `Facebook` çš„ `FAISS`,ä»¥åŠä¸€äº›ç”¨äºé«˜å¯ç”¨æ€§çŸ¢é‡æ•°æ®åº“çš„ PaaS äº§å“,ä¾‹å¦‚ `Pinecone` å’Œ `Weaviate`

# ä¸ªäººå®ç°å‘é‡æœç´¢çš„å®ç°æ€è·¯

- åœ¨ç»™å®šçš„`N`ä¸ªç‚¹ä¸Šæ„å»ºä¸€ä¸ªç®€åŒ–çš„å‘é‡æœç´¢ç´¢å¼•:

1. éšæœºå– 2 ä¸ªä»»æ„å¯ç”¨å‘é‡ A å’Œ B
2. è®¡ç®—è¿™ä¸¤ä¸ªå‘é‡ä¹‹é—´çš„ä¸­ç‚¹,ç§°ä¸º C
3. æ„å»ºä¸€ä¸ªé€šè¿‡ C å¹¶å‚ç›´äºè¿æ¥ A å’Œ B çš„çº¿æ®µçš„`è¶…å¹³é¢(ç±»ä¼¼äºæ›´é«˜ç»´åº¦çš„â€œçº¿â€)`
4. å°†æ‰€æœ‰å‘é‡åˆ†ç±»ä¸ºè¶…å¹³é¢`ä¸Šæ–¹`æˆ–`ä¸‹æ–¹`,å°†å¯ç”¨å‘é‡åˆ†æˆ 2 ç»„
5. å¯¹äºä¸¤ä¸ªç»„ä¸­çš„æ¯ä¸€ä¸ª: å¦‚æœç»„çš„å¤§å°å¤§äºå¯é…ç½®å‚æ•°`æœ€å¤§èŠ‚ç‚¹å¤§å°`,åˆ™é€’å½’åœ°å¯¹è¯¥ç»„è°ƒç”¨æ­¤è¿‡ç¨‹ä»¥æ„å»ºå­æ ‘.å¦åˆ™,ä½¿ç”¨æ‰€æœ‰å‘é‡(æˆ–å®ƒä»¬çš„`å”¯ä¸€ ID`)æ„å»ºä¸€ä¸ª`å¶èŠ‚ç‚¹`

å› æ­¤,æˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªéšæœºè¿‡ç¨‹æ¥æ„å»ºä¸€æ£µæ ‘,å…¶ä¸­æ¯ä¸ªå†…éƒ¨èŠ‚ç‚¹éƒ½æ˜¯ä¸€ä¸ªè¶…å¹³é¢å®šä¹‰,å·¦å­æ ‘æ˜¯è¶…å¹³é¢`ä¸‹æ–¹`çš„æ‰€æœ‰å‘é‡,å³å­æ ‘æ˜¯è¶…å¹³é¢`ä¸Šæ–¹`çš„æ‰€æœ‰å‘é‡.å‘é‡é›†ä¸æ–­é€’å½’æ‹†åˆ†,ç›´åˆ°å¶èŠ‚ç‚¹åŒ…å«çš„å‘é‡ä¸è¶…è¿‡`æœ€å¤§èŠ‚ç‚¹å¤§å°`.è€ƒè™‘ä¸‹å›¾ä¸­çš„ä¾‹å­æœ‰äº”ç‚¹:

<figure>
  <img src="/blog/vector.png" alt="ç”¨éšæœºè¶…å¹³é¢åˆ†å‰²ç©ºé—´" />
  <figcaption className={'text-center dark:text-amber-100'}>
    å›¾(1): ç”¨éšæœºè¶…å¹³é¢åˆ†å‰²ç©ºé—´
  </figcaption>
</figure>

æˆ‘ä»¬éšæœºé€‰æ‹©å‘é‡ `A1=(4,2)`, `B1=(5,7)`.å®ƒä»¬çš„ä¸­ç‚¹æ˜¯ `(4.5,4.5)`,æˆ‘ä»¬é€šè¿‡ä¸­ç‚¹å‚ç›´äº`çº¿ (A1, B1)` æ„å»ºä¸€æ¡çº¿.é‚£æ¡çº¿æ˜¯ `x + 5y=27`(ä»¥è“è‰²ç»˜åˆ¶),å®ƒç»™æˆ‘ä»¬ä¸€ç»„ 2 ä¸ªå‘é‡,ä¸€ç»„ 4 ä¸ª.å‡è®¾`æœ€å¤§èŠ‚ç‚¹å¤§å°`é…ç½®ä¸º 2.æˆ‘ä»¬ä¸è¿›ä¸€æ­¥æ‹†åˆ†ç¬¬ä¸€ç»„,è€Œæ˜¯é€‰æ‹©ä¸€ä¸ªæ–°çš„ `(A2, B2)` ä»åè€…æ„å»ºçº¢è‰²è¶…å¹³é¢ç­‰ç­‰.å¯¹å¤§å‹æ•°æ®é›†çš„é‡å¤æ‹†åˆ†å°†è¶…ç©ºé—´æ‹†åˆ†ä¸ºå‡ ä¸ªä¸åŒçš„åŒºåŸŸ,å¦‚ä¸‹æ‰€ç¤º

<figure>
  <img src="/blog/vector2.png" alt="è®¸å¤šè¶…å¹³é¢åçš„åˆ†æ®µç©ºé—´" />
  <figcaption className={'text-center dark:text-amber-100'}>
    å›¾(2): è®¸å¤šè¶…å¹³é¢åçš„åˆ†æ®µç©ºé—´
  </figcaption>
</figure>

è¿™é‡Œçš„æ¯ä¸ªåŒºåŸŸä»£è¡¨ä¸€ä¸ªå¶èŠ‚ç‚¹,è¿™é‡Œçš„ç›´è§‰æ˜¯è¶³å¤Ÿæ¥è¿‘çš„ç‚¹å¾ˆå¯èƒ½æœ€ç»ˆå‡ºç°åœ¨åŒä¸€ä¸ªå¶èŠ‚ç‚¹ä¸­.å› æ­¤,ç»™å®šä¸€ä¸ªæŸ¥è¯¢ç‚¹,æˆ‘ä»¬å¯ä»¥ä»¥å¯¹æ•°æ—¶é—´å‘ä¸‹éå†æ ‘ä»¥å®šä½å®ƒæ‰€å±çš„å¶å­å¹¶å¯¹å¶å­ä¸­çš„æ‰€æœ‰(å°‘é‡)ç‚¹è¿è¡Œçº¿æ€§æ‰«æ.è¿™æ˜¾ç„¶ä¸æ˜¯ä¸‡æ— ä¸€å¤±çš„ â€”â€” å®é™…ä¸Šè¶³å¤Ÿè¿‘çš„ç‚¹å®Œå…¨æœ‰å¯èƒ½è¢«ä¸€ä¸ªè¶…å¹³é¢åˆ†å¼€,æœ€ç»ˆå½¼æ­¤ç›¸è·å¾ˆè¿œ.ä½†æ˜¯è¿™ä¸ªé—®é¢˜å¯ä»¥é€šè¿‡æ„å»º`å¤šæ£µç‹¬ç«‹æ ‘`è€Œä¸æ˜¯ä¸€æ£µæ ‘æ¥è§£å†³ â€”â€” è¿™æ ·,å¦‚æœä¸¤ç‚¹è¶³å¤Ÿè¿‘,å®ƒä»¬æ›´æœ‰å¯èƒ½ä½äºè‡³å°‘æŸäº›æ ‘ä¸­çš„`åŒä¸€å¶èŠ‚ç‚¹`ä¸­.åœ¨æŸ¥è¯¢æ—¶,æˆ‘ä»¬`å‘ä¸‹éå†æ‰€æœ‰æ ‘`ä»¥å®šä½ç›¸å…³çš„å¶èŠ‚ç‚¹,å¯¹æ‰€æœ‰å¶èŠ‚ç‚¹çš„æ‰€æœ‰å€™é€‰èŠ‚ç‚¹`è¿›è¡Œå¹¶é›†`,å¹¶å¯¹æ‰€æœ‰èŠ‚ç‚¹è¿›è¡Œ`çº¿æ€§æ‰«æ`

```rust showLineNumbers
#[derive(Eq, PartialEq, Hash)]
pub struct HashKey<const N: usize>([u32; N]);

#[derive(Copy, Clone)]
pub struct Vector<const N: usize>(pub [f32; N]);
impl<const N: usize> Vector<N> {
    pub fn subtract_from(&self, vector: &Vector<N>) -> Vector<N> {
        let mapped = self.0.iter().zip(vector.0).map(|(a, b)| b - a);
        let coords: [f32; N] = mapped.collect::<Vec<_>>().try_into().unwrap();
        return Vector(coords);
    }
    pub fn avg(&self, vector: &Vector<N>) -> Vector<N> {
        let mapped = self.0.iter().zip(vector.0).map(|(a, b)| (a + b) / 2.0);
        let coords: [f32; N] = mapped.collect::<Vec<_>>().try_into().unwrap();
        return Vector(coords);
    }
    pub fn dot_product(&self, vector: &Vector<N>) -> f32 {
        let zipped_iter = self.0.iter().zip(vector.0);
        return zipped_iter.map(|(a, b)| a * b).sum::<f32>();
    }
    pub fn to_hashkey(&self) -> HashKey<N> {
        // f32 in Rust doesn't implement hash. We use bytes to dedup. While it
        // can't differentiate ~16M ways NaN is written, it's safe for us
        let bit_iter = self.0.iter().map(|a| a.to_bits());
        let data: [u32; N] = bit_iter.collect::<Vec<_>>().try_into().unwrap();
        return HashKey::<N>(data);
    }
    pub fn sq_euc_dis(&self, vector: &Vector<N>) -> f32 {
        let zipped_iter = self.0.iter().zip(vector.0);
        return zipped_iter.map(|(a, b)| (a - b).powi(2)).sum();
    }
}
```

æ„å»ºå®Œè¿™äº›æ ¸å¿ƒå®ç”¨ç¨‹åºå,æˆ‘ä»¬è¿˜å¯ä»¥å®šä¹‰è¶…å¹³é¢çš„å¤–è§‚:

```rust
struct HyperPlane<const N: usize> {
    coefficients: Vector<N>,
    constant: f32,
}

impl<const N: usize> HyperPlane<N> {
    pub fn point_is_above(&self, point: &Vector<N>) -> bool {
        self.coefficients.dot_product(point) + self.constant >= 0.0
    }
}
```

# å¦‚ä½•è¡¨ç¤ºæ ‘ ğŸŒ² ä¸­çš„ç‚¹

æˆ‘ä»¬å¯ä»¥ç›´æ¥å°† D ç»´å‘é‡å­˜å‚¨åœ¨å¶èŠ‚ç‚¹ä¸­.ä½†æ˜¯,å¯¹äºå¤§ D,è¿™ä¼šæ˜¾ç€ç¢ç‰‡åŒ–å†…å­˜(ä¸»è¦æ€§èƒ½å½±å“),å¹¶ä¸”å½“å¤šæ£µæ ‘å¼•ç”¨ç›¸åŒçš„å‘é‡æ—¶,è¿˜ä¼šåœ¨æ£®æ—ä¸­åˆ›å»ºé‡å¤å†…å­˜.ç›¸å,æˆ‘ä»¬å°†å‘é‡å­˜å‚¨åœ¨å…¨å±€è¿ç»­ä½ç½®,å¹¶åœ¨å¶èŠ‚ç‚¹å¤„ä¿å­˜ usize ç´¢å¼•(åœ¨ 64 ä½ç³»ç»Ÿä¸Šä¸º 8 å­—èŠ‚è€Œä¸æ˜¯ 4D,å…¶ä¸­ f32 å ç”¨ 4 å­—èŠ‚).ä»¥ä¸‹æ˜¯ç”¨äºè¡¨ç¤ºæ ‘çš„å†…éƒ¨èŠ‚ç‚¹å’Œå¶èŠ‚ç‚¹çš„æ•°æ®ç±»å‹

```rust
enum Node<const N: usize> {
    Inner(Box<InnerNode<N>>),
    Leaf(Box<LeafNode<N>>),
}
struct LeafNode<const N: usize>(Vec<usize>);
struct InnerNode<const N: usize> {
    hyperplane: HyperPlane<N>,
    left_node: Node<N>,
    right_node: Node<N>,
}
pub struct ANNIndex<const N: usize> {
    trees: Vec<Node<N>>,
    ids: Vec<i32>,
    values: Vec<Vector<N>>,
}
```

# æ‰¾åˆ°æ­£ç¡®çš„è¶…å¹³é¢

å¯¹å‘é‡ A å’Œ B é‡‡æ ·ä¸¤ä¸ªå”¯ä¸€ç´¢å¼•,è®¡ç®— `n = A - B`,å¹¶æ‰¾åˆ° A å’Œ B çš„ä¸­ç‚¹(point_on_plane).è¶…å¹³é¢ä½¿ç”¨ç³»æ•°`å‘é‡ n`å’Œå¸¸é‡(n å’Œ point_on_plane çš„ç‚¹ç§¯)ç»“æ„æœ‰æ•ˆåœ°å­˜å‚¨ä¸º `n(x-x0) = nx - nx0`.æˆ‘ä»¬å¯ä»¥åœ¨ä»»ä½•å‘é‡å’Œ n ä¹‹é—´æ‰§è¡Œç‚¹ç§¯,ç„¶åå‡å»å¸¸æ•°ä»¥å°†å‘é‡æ”¾åœ¨è¶…å¹³é¢`â€œä¸Šæ–¹â€`æˆ–`â€œä¸‹æ–¹â€`.ç”±äºæ ‘ä¸­çš„å†…éƒ¨èŠ‚ç‚¹åŒ…å«è¶…å¹³é¢å®šä¹‰,å¶èŠ‚ç‚¹åŒ…å«å‘é‡ ID,å› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `ADT` å¯¹æ ‘è¿›è¡Œç±»å‹æ£€æŸ¥ï¼š

```rust
impl<const N: usize> ANNIndex<N> {
    fn build_hyperplane(
        indexes: &Vec<usize>,
        all_vecs: &Vec<Vector<N>>,
    ) -> (HyperPlane<N>, Vec<usize>, Vec<usize>) {
        let sample: Vec<_> = indexes
            .choose_multiple(&mut rand::thread_rng(), 2)
            .collect();
        // cartesian eq for hyperplane n * (x - x_0) = 0
        // n (normal vector) is the coefs x_1 to x_n
        let (a, b) = (*sample[0], *sample[1]);
        let coefficients = all_vecs[a].subtract_from(&all_vecs[b]);
        let point_on_plane = all_vecs[a].avg(&all_vecs[b]);
        let constant = -coefficients.dot_product(&point_on_plane);
        let hyperplane = HyperPlane::<N> {
            coefficients,
            constant,
        };
        let (mut above, mut below) = (vec![], vec![]);
        for &id in indexes.iter() {
            if hyperplane.point_is_above(&all_vecs[id]) {
                above.push(id)
            } else {
                below.push(id)
            };
        }
        return (hyperplane, above, below);
    }
}
```

æˆ‘ä»¬å¯ä»¥å®šä¹‰æˆ‘ä»¬çš„é€’å½’è¿‡ç¨‹ä»¥åŸºäºç´¢å¼•æ—¶é—´`â€œæœ€å¤§èŠ‚ç‚¹å¤§å°â€`æ„å»ºæ ‘:

```rust
impl<const N: usize> ANNIndex<N> {
    fn build_a_tree(
        max_size: i32,
        indexes: &Vec<usize>,
        all_vecs: &Vec<Vector<N>>,
    ) -> Node<N> {
        if indexes.len() <= (max_size as usize) {
            return Node::Leaf(Box::new(LeafNode::<N>(indexes.clone())));
        }
        let (plane, above, below) = Self::build_hyperplane(indexes, all_vecs);
        let node_above = Self::build_a_tree(max_size, &above, all_vecs);
        let node_below = Self::build_a_tree(max_size, &below, all_vecs);
        return Node::Inner(Box::new(InnerNode::<N> {
            hyperplane: plane,
            left_node: node_below,
            right_node: node_above,
        }));
    }
}
```

âš ï¸ è¯·æ³¨æ„,åœ¨ä¸¤ç‚¹ä¹‹é—´æ„å»ºè¶…å¹³é¢éœ€è¦è¿™ä¸¤ç‚¹æ˜¯å”¯ä¸€çš„ - å³æˆ‘ä»¬å¿…é¡»åœ¨ç´¢å¼•ä¹‹å‰å¯¹å‘é‡é›†è¿›è¡Œå»é‡,å› ä¸ºè¯¥ç®—æ³•ä¸å…è®¸é‡å¤

å› æ­¤æ•´ä¸ªç´¢å¼•(æ ‘çš„æ£®æ—)å¯ä»¥è¿™æ ·æ„å»º:

```rust
impl<const N: usize> ANNIndex<N> {
    fn deduplicate(
        vectors: &Vec<Vector<N>>,
        ids: &Vec<i32>,
        dedup_vectors: &mut Vec<Vector<N>>,
        ids_of_dedup_vectors: &mut Vec<i32>,
    ) {
        let mut hashes_seen = HashSet::new();
        for i in 1..vectors.len() {
            let hash_key = vectors[i].to_hashkey();
            if !hashes_seen.contains(&hash_key) {
                hashes_seen.insert(hash_key);
                dedup_vectors.push(vectors[i]);
                ids_of_dedup_vectors.push(ids[i]);
            }
        }
    }

    pub fn build_index(
        num_trees: i32,
        max_size: i32,
        vecs: &Vec<Vector<N>>,
        vec_ids: &Vec<i32>,
    ) -> ANNIndex<N> {
        let (mut unique_vecs, mut ids) = (vec![], vec![]);
        Self::deduplicate(vecs, vec_ids, &mut unique_vecs, &mut ids);
        // Trees hold an index into the [unique_vecs] list which is not
        // necessarily its id, if duplicates existed
        let all_indexes: Vec<usize> = (0..unique_vecs.len()).collect();
        let trees: Vec<_> = (0..num_trees)
            .map(|_| Self::build_a_tree(max_size, &all_indexes, &unique_vecs))
            .collect();
        return ANNIndex::<N> {
            trees,
            ids,
            values: unique_vecs,
        };
    }
}
```

# æŸ¥è¯¢æ—¶é—´

å»ºç«‹ç´¢å¼•å,æˆ‘ä»¬å¦‚ä½•ä½¿ç”¨å®ƒåœ¨å•ä¸ªæ ‘ä¸Šæœç´¢è¾“å…¥å‘é‡çš„ K ä¸ªè¿‘ä¼¼æœ€è¿‘é‚»?åœ¨éå¶èŠ‚ç‚¹å¤„,æˆ‘ä»¬å­˜å‚¨è¶…å¹³é¢,å› æ­¤æˆ‘ä»¬å¯ä»¥ä»æ ‘çš„æ ¹å¼€å§‹å¹¶è¯¢é—®ï¼šâ€œè¿™ä¸ªå‘é‡æ˜¯åœ¨è¿™ä¸ªè¶…å¹³é¢ä¹‹ä¸Šè¿˜æ˜¯ä¹‹ä¸‹?â€.è¿™å¯ä»¥ç”¨ç‚¹ç§¯åœ¨ `O(D)` ä¸­è®¡ç®—.æ ¹æ®å“åº”,æˆ‘ä»¬å¯ä»¥é€’å½’æœç´¢å·¦å­æ ‘æˆ–å³å­æ ‘,ç›´åˆ°æ‰¾åˆ°å¶èŠ‚ç‚¹.è¯·è®°ä½,å¶èŠ‚ç‚¹æœ€å¤šå­˜å‚¨`â€œæœ€å¤§èŠ‚ç‚¹å¤§å°â€`å‘é‡,è¿™äº›å‘é‡ä½äºè¾“å…¥å‘é‡çš„è¿‘ä¼¼é‚»åŸŸå†…(å› ä¸ºå®ƒä»¬è½åœ¨æ‰€æœ‰è¶…å¹³é¢ä¸‹çš„è¶…ç©ºé—´çš„åŒä¸€åˆ†åŒºä¸­,è¯·å‚è§å›¾ 1(b)).å¦‚æœè¿™ä¸ªå¶èŠ‚ç‚¹çš„å‘é‡ç´¢å¼•æ•°è¶…è¿‡ K,æˆ‘ä»¬ç°åœ¨å¯ä»¥æŒ‰ç…§åˆ°è¾“å…¥å‘é‡çš„ L2 è·ç¦»å¯¹æ‰€æœ‰è¿™äº›å‘é‡è¿›è¡Œæ’åº,å¹¶è¿”å›æœ€æ¥è¿‘çš„ Kï¼

å‡è®¾æˆ‘ä»¬çš„ç´¢å¼•å¯¼è‡´ä¸€æ£µ`å¹³è¡¡æ ‘`,å¯¹äºç»´åº¦ Dã€å‘é‡æ•° N å’Œæœ€å¤§èŠ‚ç‚¹å¤§å° `M << N`,æœç´¢éœ€è¦ `O(Dlog(N) + DM + Mlog(M))` - è¿™æ„æˆäº†`å¹³å‡æœ€å·®- case log(N)` è¶…å¹³é¢æ¯”è¾ƒæ‰¾åˆ°ä¸€ä¸ªå¶å­èŠ‚ç‚¹(ä¹Ÿå°±æ˜¯æ ‘çš„é«˜åº¦),å…¶ä¸­æ¯æ¬¡æ¯”è¾ƒèŠ±è´¹ `O(D)` ç‚¹ç§¯,åœ¨ `O(DM)` ä¸­è®¡ç®—ä¸€ä¸ªå¶å­èŠ‚ç‚¹ä¸­æ‰€æœ‰å€™é€‰å‘é‡çš„ L2 åº¦é‡æœ€åå¯¹å®ƒä»¬è¿›è¡Œæ’åºä»¥è¿”å› `O(Mlog(M)) ä¸­çš„å‰ K ä¸ª`

ä½†æ˜¯,å¦‚æœæˆ‘ä»¬æ‰¾åˆ°çš„å¶èŠ‚ç‚¹å°‘äº K ä¸ªå‘é‡,ä¼šå‘ç”Ÿä»€ä¹ˆæƒ…å†µ?å¦‚æœæœ€å¤§èŠ‚ç‚¹å¤§å°å¤ªå°æˆ–å­˜åœ¨ç›¸å¯¹ä¸å‡åŒ€çš„è¶…å¹³é¢åˆ†è£‚,åˆ™å¯èƒ½ä¼šåœ¨å­æ ‘ä¸­ç•™ä¸‹éå¸¸å°‘çš„å‘é‡.ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜,æˆ‘ä»¬å¯ä»¥åœ¨æ ‘æœç´¢ä¸­æ·»åŠ ä¸€äº›ç®€å•çš„å›æº¯åŠŸèƒ½.ä¾‹å¦‚,å¦‚æœè¿”å›çš„å€™é€‰é¡¹æ•°é‡ä¸è¶³,æˆ‘ä»¬å¯ä»¥åœ¨å†…éƒ¨èŠ‚ç‚¹è¿›è¡Œé¢å¤–çš„é€’å½’è°ƒç”¨ä»¥è®¿é—®å¦ä¸€ä¸ªåˆ†æ”¯.è¿™å°±æ˜¯å®ƒçš„æ ·å­:

```rust
impl<const N: usize> ANNIndex<N> {
    fn tree_result(
        query: Vector<N>,
        n: i32,
        tree: &Node<N>,
        candidates: &mut HashSet<usize>,
    ) -> i32 {
        // take everything in node, if still needed, take from alternate subtree
        match tree {
            Node::Leaf(box_leaf) => {
                let leaf_values = &(box_leaf.0);
                let num_candidates_found = min(n as usize, leaf_values.len());
                for i in 0..num_candidates_found {
                    candidates.insert(leaf_values[i]);
                }
                return num_candidates_found as i32;
            }
            Node::Inner(inner) => {
                let above = (*inner).hyperplane.point_is_above(&query);
                let (main, backup) = match above {
                    true => (&(inner.right_node), &(inner.left_node)),
                    false => (&(inner.left_node), &(inner.right_node)),
                };
                match Self::tree_result(query, n, main, candidates) {
                    k if k < n => {
                        k + Self::tree_result(query, n - k, backup, candidates)
                    }
                    k => k,
                }
            }
        }
    }
}
```

è¯·æ³¨æ„,æˆ‘ä»¬è¿˜å¯ä»¥é€šè¿‡å­˜å‚¨å­æ ‘ä¸­çš„å‘é‡æ€»æ•°å’Œç›´æ¥æŒ‡å‘æ¯ä¸ªå†…éƒ¨èŠ‚ç‚¹çš„æ‰€æœ‰å¶èŠ‚ç‚¹çš„æŒ‡é’ˆåˆ—è¡¨æ¥è¿›ä¸€æ­¥ä¼˜åŒ–é€’å½’è°ƒç”¨,ä½†ä¸ºç®€å•èµ·è§,æ­¤å¤„ä¸è¿™æ ·åš

å°†æ­¤æœç´¢æ‰©å±•åˆ°æ ‘æœ¨æ£®æ—æ˜¯å¾®ä¸è¶³é“çš„ - åªéœ€ä»æ‰€æœ‰æ ‘æœ¨ä¸­ç‹¬ç«‹æ”¶é›†å‰ K ä¸ªå€™é€‰è€…,æŒ‰è·ç¦»å¯¹å®ƒä»¬è¿›è¡Œæ’åº,ç„¶åè¿”å›æ€»ä½“å‰ K ä¸ªåŒ¹é…é¡¹.è¯·æ³¨æ„,æ›´å¤šçš„æ ‘å°†å…·æœ‰çº¿æ€§é«˜çš„å†…å­˜å ç”¨å’Œçº¿æ€§ç¼©æ”¾çš„æœç´¢æ—¶é—´,ä½†å¯ä»¥å¯¼è‡´æ›´å¥½çš„â€œæ›´è¿‘â€é‚»å±…,å› ä¸ºæˆ‘ä»¬æ”¶é›†äº†ä¸åŒæ ‘çš„å€™é€‰è€…

```rust
impl<const N: usize> ANNIndex<N> {
    pub fn search_approximate(
        &self,
        query: Vector<N>,
        top_k: i32,
    ) -> Vec<(i32, f32)> {
        let mut candidates = HashSet::new();
        for tree in self.trees.iter() {
            Self::tree_result(query, top_k, tree, &mut candidates);
        }
        candidates
            .into_iter()
            .map(|idx| (idx, self.values[idx].sq_euc_dis(&query)))
            .sorted_by(|a, b| a.1.partial_cmp(&b.1).unwrap())
            .take(top_k as usize)
            .map(|(idx, dis)| (self.ids[idx], dis))
            .collect()
    }
}
```

è¿™åœ¨ 200 è¡Œ Rust ä¸­ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªç®€å•çš„`å‘é‡æœç´¢ç´¢å¼•!`

# è¡¥å……

æ­¤ç¤ºä¾‹è·³è¿‡äº†å‡ ä¸ªå¯¹ç”Ÿäº§å‘é‡æœç´¢è‡³å…³é‡è¦çš„æ³¨æ„äº‹é¡¹:

- å½“æœç´¢æ¶‰åŠå¤šæ£µæ ‘æ—¶å¹¶è¡ŒåŒ–.æˆ‘ä»¬å¯ä»¥å¹¶è¡ŒåŒ–è€Œä¸æ˜¯æŒ‰é¡ºåºæ”¶é›†å€™é€‰è€…,å› ä¸ºæ¯æ£µæ ‘éƒ½è®¿é—®ä¸åŒçš„å†…å­˜â€”â€”æ¯æ£µæ ‘éƒ½å¯ä»¥åœ¨å•ç‹¬çš„çº¿ç¨‹ä¸Šè¿è¡Œ,å€™é€‰è€…é€šè¿‡é€šé“ä¸­çš„æ¶ˆæ¯ä¸æ–­åœ°å‘é€åˆ°ä¸»è¿›ç¨‹.çº¿ç¨‹å¯ä»¥åœ¨ç´¢å¼•æ—¶é—´æœ¬èº«äº§ç”Ÿ,å¹¶é€šè¿‡è™šæ‹Ÿæœç´¢(æ ‘çš„éƒ¨åˆ†ä½äºç¼“å­˜ä¸­)è¿›è¡Œé¢„çƒ­,ä»¥å‡å°‘æœç´¢å¼€é”€.æœç´¢å°†ä¸å†æŒ‰æ ‘çš„æ•°é‡çº¿æ€§æ‰©å±•.

- å¤§æ ‘å¯èƒ½ä¸é€‚åˆ RAM,éœ€è¦æœ‰æ•ˆçš„æ–¹æ³•ä»ç£ç›˜è¯»å– - æŸäº›å­å›¾å¯èƒ½éœ€è¦åœ¨ç£ç›˜ä¸Š,å¹¶ä¸”ç®—æ³•è®¾è®¡ä¸ºå…è®¸æœç´¢åŒæ—¶æœ€å°åŒ–æ–‡ä»¶ I/O.

- æ›´è¿›ä¸€æ­¥,å¦‚æœæ ‘ä¸é€‚åˆå®ä¾‹çš„ç£ç›˜,æˆ‘ä»¬éœ€è¦è·¨å®ä¾‹åˆ†å¸ƒå­æ ‘,å¹¶ä¸”å¦‚æœæ•°æ®åœ¨æœ¬åœ°ä¸å¯ç”¨,é€’å½’æœç´¢è°ƒç”¨ä¼šè§¦å‘ä¸€äº› `RPC è¯·æ±‚`.

- è¯¥æ ‘æ¶‰åŠè®¸å¤šå†…å­˜é‡å®šå‘(åŸºäºæŒ‡é’ˆçš„æ ‘å¯¹ L1 ç¼“å­˜ä¸å‹å¥½).å¹³è¡¡æ ‘å¯ä»¥ç”¨æ•°ç»„å¾ˆå¥½åœ°ç¼–å†™,ä½†æˆ‘ä»¬çš„æ ‘ä»…ä¸éšæœºè¶…å¹³é¢æ¥è¿‘å¹³è¡¡â€”â€”æˆ‘ä»¬å¯ä»¥ä¸ºæ ‘ä½¿ç”¨æ–°çš„æ•°æ®ç»“æ„å—?

- å½“æ–°æ•°æ®è¢«åŠ¨æ€ç´¢å¼•æ—¶(å¯èƒ½éœ€è¦å¯¹å¤§æ ‘é‡æ–°åˆ†ç‰‡),ä¸Šè¿°é—®é¢˜çš„è§£å†³æ–¹æ¡ˆä¹Ÿåº”è¯¥é€‚ç”¨.å¦‚æœæŸä¸ªç´¢å¼•åºåˆ—å¯¼è‡´æ ‘é«˜åº¦ä¸å¹³è¡¡,æ˜¯å¦åº”è¯¥é‡æ–°åˆ›å»ºæ ‘?
